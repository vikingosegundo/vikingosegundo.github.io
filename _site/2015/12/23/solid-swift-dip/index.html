<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Manuel Meyer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">

  <link href="/stylesheets/more.css" rel="stylesheet">
  <link href="/stylesheets/syntax.css" rel="stylesheet">
</head>

<body>
  <div id="header">
    <a href="/"><div class="avatar">&nbsp;</div></a>
      <div class="personal-details">
        <a href="/"><h1>Manuel Meyer</h1></a>
        <p>
          Software Engineer
        </p>
        <ul>
          <li><a href="http://stackoverflow.com/users/106435/vikingosegundo">stackoverflow</a></li>
          <li><a href="http://github.com/vikingosegundo">github</a></li>
          <li><a href="http://twitter.com/vikingosegundo">twitter</a></li>
        </ul>
      </div>
  </div>

  <div class="container">

<div id="content">

<div class="row-fluid">
  <div class="span8">
    <h1>SOLID Swift, Dependency Inversion Principle</h1>

    <p>This is he first article in a series about applying the SOLID principles in Swift,
mainly for the iOS and Mac platforms. I will not start with the <em>S</em>, but with the <em>D</em>
— The Dependency Inversion Principle, DIP</p>

<!--break-->


<p>What does the DIP state?</p>

<blockquote><p>High-level modules should not depend on low-level modules. Both should depend on abstractions.</p>

<p>Abstractions should not depend on details. Details should depend on abstractions.</p></blockquote>

<p>In context of Swift we could say</p>

<blockquote><p>High-level types should not depend on low-level types, both should depend on protocols.</p>

<p>Protocols should not depend on details. Details should depend on protocols.</p></blockquote>

<h2>Evolution of a struct</h2>

<p>lets say we have a struct to keep track of the hours we worked each day.</p>

<pre><code class="objc">struct TrackedHours {

    let date: NSDate
    let duration: Double

    init(date: NSDate, duration: Double) {
        self.date = date
        self.duration = duration
    }
}
</code></pre>

<p>Now this struct does want we want, but it might be a little tedious to use, as
we first must create a NSDate instance to pass it in.</p>

<pre><code class="objc">TrackedHours(date: { let c = NSDateComponents(); c.day = 29; c.month = 11; c.year = 2015;  return NSCalendar.currentCalendar().dateFromComponents(c)!}(), duration: 7),
</code></pre>

<p>We could add an init that takes a date string and creates a date formatter to use
<code>dateFromString()</code> to create the date.<br/>
As <code>dateFromString()</code> can return <code>nil</code>, we introduce some error handling</p>

<pre><code class="objc">
enum TrackedHoursError: ErrorType {
    case InvalidDate
}

struct TrackedHours {

    let date: NSDate
    let duration: Double

    init(date: NSDate, duration: Double) {
        self.date = date
        self.duration = duration
    }

    init (dateString:String, duration:Double) throws {
        let dateFormatter = NSDateFormatter()
        dateFormatter.dateFormat = "MMM d, y"
        let date = dateFormatter.dateFromString(dateString)
        guard date != nil else { throw TrackedHoursError.InvalidDate}
        self.init(date: date!, duration:duration)
    }
}
</code></pre>

<p>Now the struct is much easier to use</p>

<pre><code class="objc">try? TrackedHours(dateString: "Nov 29, 2015", time: 7)
</code></pre>

<p>But we have a hidden dependency, as it depends on NSDateFormatter now. Further-more
we are tied to a single date format. If the user of this struct needs to deal with
other formats, the convenient init is useless.</p>

<p>Instead we should inject any dependency.</p>

<p>Dependency <em>Injection</em>? Wasn't this article suppose to cover Dependency <em>Inversion</em>?</p>

<p>Well, yes: Dependency Injection (DI) is one way of conform to the Dependency Inversion Principle (DIP).</p>

<p>Often your hear about Dependency Injection Frameworks, Reflection,… , but seriously: It is much simple:</p>

<blockquote><p>Dependency injection means giving an object its instance variables. Really. That's it. — <a href="http://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html">James Shore</a></p></blockquote>

<p>So this means we could just add a date formatter object to our struct, but actually we don't need to write it to a property,
but that is an implementation detail. Only the convenient init needs to use the
formatter, we don't need to keep it.</p>

<pre><code class="objc">enum TrackedHoursError: ErrorType {
    case InvalidDate
}

struct TrackedHours {

    let date: NSDate
    let duration: Double

    init(date: NSDate, duration: Double) {
        self.date = date
        self.duration = duration
    }

    init (dateFormatter:NSDateFormatter, dateString:String, duration:Double) throws {
        let date = dateFormatter.dateFromString(dateString)
        guard date != nil else { throw TrackedHoursError.InvalidDate}
        self.init(date: date!, duration:duration)
    }
}
</code></pre>

<p>Now we can pas in a date formatter with the format we need.</p>

<pre><code class="objc">let dateFormatter = NSDateFormatter()
dateFormatter.dateFormat = "MMM d, y"
try? TrackedHours(dateFormatter: dateFormatter, dateString: "Nov 29, 2015", duration: 7),
</code></pre>

<p>Now our struct complies to Dependency Injection, and in most cases this is just as good as perfect —
but in regards to Dependency <em>Injection</em> it isn't perfect. Our struct depends on a concrete
NSDateFormatter, rather than on a protocol or abstraction. Sou we should type the <code>dateFormatter</code>
parameter in the <code>init</code> with an protocol that <code>NSDateFormatter</code> implements. But there
isn't any.</p>

<p>Well, let us create one using an <code>extension</code></p>

<p>For now e will give the protocol the only method we need from <code>NSDateFormatter</code></p>

<pre><code class="objc">protocol DateFormatting {
    func dateFromString(string: String) -&gt; NSDate?
}
</code></pre>

<p>and create an empty extension to indicate that NSDateFormatter implements the
protocol.</p>

<pre><code class="objc">extension NSDateFormatter : DateFormatting {
}
</code></pre>

<p>thats it! Now we can type the <code>dateFormatter</code> parameter as <code>DateFormatting</code></p>

<pre><code class="objc">struct TrackedHours {

    let date: NSDate
    let duration: Double

    init(date: NSDate, duration: Double) {
        self.date = date
        self.duration = duration
    }

    init (dateFormatter:DateFormatting, dateString:String, duration:Double) throws {
        let date = dateFormatter.dateFromString(dateString)
        guard date != nil else { throw TrackedHoursError.InvalidDate}
        self.init(date: date!, duration:duration)
    }
}
</code></pre>

<p>But why is it better to type it as the protocol and not the concrete type <code>NSDateFormatter</code>?</p>

<p>Imagine your data about the tracked hours comes from different sources in different formats.
Now it is easy to create an instance that conforms to <code>DateFormatting</code> by keeping
a list of date formatter and ask each of it to create a date from a string, it
would be a light weight proxy.</p>

<p>At the end of this post you will find the complete post. Including the object proxying the
date formatters.</p>

<p>A word of warning: You should <strong>NEVER</strong> handle different date formats like this.<br/>
You should know with data source uses which date format and normalize it upon receiving data.<br/>
If you uncomment the line marked /*⛈*/, you will see that an <code>AmbigousDate</code> error is thrown,
as the 2nd and the 3rd date formatters will both understand it — differently.</p>

<pre><code class="swift">import Foundation


protocol DateFormatting {
    func dateFromString(string: String)  -&gt; NSDate?

    func error() -&gt; TrackedHoursError?

}

extension NSDateFormatter : DateFormatting {
    func error() -&gt; TrackedHoursError? {
        return nil
    }

}


enum TrackedHoursError: ErrorType {
    case InvalidDate
    case AmbigousDate(String)
}

struct TrackedHours {

    let date: NSDate
    let duration: Double

    init(date: NSDate, duration: Double) {
        self.date = date
        self.duration = duration
    }

    init (dateFormatter:DateFormatting, dateString:String, duration:Double) throws {
        let date =  dateFormatter.dateFromString(dateString)
        guard date != nil else {
            if let error = dateFormatter.error() {
                throw error
            } else {
                throw TrackedHoursError.InvalidDate
            }
        }
        self.init(date: date!, duration:duration)
    }
}

class MultiDateFormatter : DateFormatting {

    let dateFormatters: [DateFormatting]
    init(dateFormatters: [DateFormatting]){
        self.dateFormatters = dateFormatters
    }
    private var _error: TrackedHoursError?

    func error() -&gt; TrackedHoursError? { return _error }

    func dateFromString(string: String)  -&gt; NSDate? {

        var possibleDates = [NSDate]()
        for df in dateFormatters {
            if let date = df.dateFromString(string) {
                possibleDates.append(date)
            }
        }
        guard possibleDates.count &lt; 2 else { self._error = .AmbigousDate(string); return nil }
        guard possibleDates.count == 1 else { return nil }
        return possibleDates[0]
    }
}



do {
    let currentMonth = NSCalendar.currentCalendar().dateFromComponents({
            let comps = NSDateComponents();
            comps.day = 1;
            comps.month = 12;
            comps.year = 2015;
            return comps
        }())!
    let multiDateFormatter = MultiDateFormatter(dateFormatters: [
        {let df = NSDateFormatter(); df.dateFormat = "yyyy, MM, dd"; return df}(),
        {let df = NSDateFormatter(); df.dateFormat = "dd, MM, yyyy"; return df}(),
        {let df = NSDateFormatter(); df.dateFormat = "MM, dd, yyyy"; return df}()
        ])


    let hoursData = [
        try TrackedHours(dateFormatter: multiDateFormatter, dateString: "11/29, 2015",       duration: 7.1),
        try TrackedHours(dateFormatter: multiDateFormatter, dateString: "December 12, 2015", duration: 7.5),
        try TrackedHours(dateFormatter: multiDateFormatter, dateString: "13.12.2015",        duration: 7.1),
        try TrackedHours(dateFormatter: multiDateFormatter, dateString: "14/12/2015",        duration: 8.0),
        try TrackedHours(dateFormatter: multiDateFormatter, dateString: "2015-12-15",        duration: 8.1),
        try TrackedHours(dateFormatter: multiDateFormatter, dateString: "Dec 12, 2015",      duration: 7.1),
//      try TrackedHours(dateFormatter: multiDateFormatter, dateString: "1 12, 2015",      duration: 7.1)/*⛈*/

    ]


    let totalDuration = hoursData.filter{
        let objectsComps = NSCalendar.currentCalendar().components([.Month, .Year], fromDate: $0.date)
        let todaysComps  = NSCalendar.currentCalendar().components([.Month, .Year], fromDate: currentMonth)
        return objectsComps.month == todaysComps.month &amp;&amp; objectsComps.year == todaysComps.year
        }.reduce(0) {
            $0 + $1.duration
    }
    print(totalDuration)
} catch TrackedHoursError.InvalidDate{
    print("one or more datestrings must be wrong")
}  catch TrackedHoursError.AmbigousDate(let string){
    print("more than one dateformatter were able to interprete this string: \(string)")
}
</code></pre>

  </div>
  <div class="span4">
  </div>

  <div id="disqus_thread"></div>
  <script type="text/javascript">
      /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
      var disqus_shortname = 'vikingosegundo'; // required: replace example with your forum shortname

      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  
</div>
</div>
</div>
</body>
</html>

