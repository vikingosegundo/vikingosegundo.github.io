<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Manuel Meyer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">

  <link href="/stylesheets/more.css" rel="stylesheet">
  <link href="/stylesheets/syntax.css" rel="stylesheet">
</head>

<body>
  <div id="header">
    <a href="/"><div class="avatar">&nbsp;</div></a>
      <div class="personal-details">
        <a href="/"><h1>Manuel Meyer</h1></a>
        <p>
          Software Engineer
        </p>
        <ul>
          <li><a href="http://stackoverflow.com/users/106435/vikingosegundo">stackoverflow</a></li>
          <li><a href="http://github.com/vikingosegundo">github</a></li>
          <li><a href="http://twitter.com/vikingosegundo">twitter</a></li>
        </ul>
      </div>
  </div>

  <div class="container">

<div id="content">
    <div>
      <div>
        
<div class="post">

<h2><a href="/2015/02/05/implement-comparator/">Implement Comparator</a></h2>
<h4>05 February 2015</h4>
<p>This shows how to implement a block based sorting with the quicksort algorithm.</p>

<p>in response to this <a href="http://stackoverflow.com/questions/28348022/how-is-the-sortedarrayusingcomparator-method-written-in-objective-c/28349545#28349545">Stackoverflow question</a></p>

<h3>NSArray+FunctionalTool</h3>

<pre><code class="Objective-C">
#import &lt;Foundation/Foundation.h&gt;

typedef id (^VSTestBlock)(id element);
@interface NSArray (FunctionalTools)
- (NSArray*)filter:(BOOL(^)(id element))filterBlock;

+(NSArray *)arrayByPerformingBlock:(id(^)(NSInteger index))performBlock
        withIndexFromRange:(NSRange)range;

- (NSArray *)arrayByPerformingBlock:(id  (^)(id element))performBlock;

- (NSArray *)arrayByPerformingBlock:(id  (^)(id element))performBlock
        ifElementPassesTest:(BOOL(^)(id element))testBlock;

- (NSArray *)arrayByPerformingBlock:(id   (^)(id element))performBlock
        ifElementPassesTest:(BOOL (^)(id element))testBlock
           elsePerformBlock:(void (^)(id element))elseBlock;

- (NSArray *)arrayByPerformingBlock:(id   (^)(id element))performBlock
        ifElementPassesTest:(BOOL (^)(id element))testBlock
           elsePerformBlock:(void (^)(id element))elseBlock
               succeded:(void (^) ())succesBlock
               failed:(void (^)(id element))failedBlock
           stopOnFailedTest:(BOOL)stop;


-(NSSet *)setByPerformingBlock:(id  (^)(id element))performBlock
           ifElementPassesTest:(BOOL (^)(id element))testBlock;

- (NSDictionary *)dictionaryByFilteringWithBlocks:(NSArray *)filterBlocks forKeys:(NSArray *)keys;

-(NSArray *)arrayOfArraysWithColumnWidth:(NSUInteger)width;


-(void)performBlock:(void (^) (id element))block;
@end
</code></pre>

<pre><code class="Objective-C">//
//  NSArray+FuntionalTools.m
//  arraytools
//
//  Created by vikingosegundo on 28.08.11.
//  Copyright (c) 2011 vikingosegundo. All rights reserved.
//

#import "NSArray+FunctionalTools.h"

@implementation NSArray (FunctionalTools)
-(NSArray *)filter:(BOOL (^)(id))filterBlock
{
  NSMutableArray *filteredArray = [NSMutableArray array];
  for (id element in self)
    if (filterBlock(element))
      [filteredArray addObject:element];
  return [NSArray arrayWithArray:filteredArray];
}

+(NSArray *)arrayByPerformingBlock:(id (^)(NSInteger))performBlock withIndexFromRange:(NSRange)range
{
  NSMutableArray *array = [NSMutableArray array];
  for (NSUInteger i = range.location; i&lt; range.location+range.length; ++i) {
    [array addObject:performBlock(i)];
  }
  return array;
}


- (NSArray *)arrayByPerformingBlock:(id  (^)(id element))performBlock
{
  return [self arrayByPerformingBlock:performBlock
          ifElementPassesTest:^BOOL(id element) { return  YES;}];
}


- (NSArray *)arrayByPerformingBlock:(id(^)(id element))performBlock
             ifElementPassesTest:(BOOL(^)(id element))testBlock
{

  return [self arrayByPerformingBlock:performBlock
               ifElementPassesTest:testBlock
             elsePerformBlock:^(id element){;}];
}


-(NSArray *)arrayByPerformingBlock:(id (^)(id))performBlock
            ifElementPassesTest:(BOOL (^)(id))testBlock
          elsePerformBlock:(void (^)(id))elseBlock
{
  NSMutableArray *array = [NSMutableArray array];
  for (id element in self)
    if(testBlock(element))
      [array addObject:performBlock(element)];
    else
      elseBlock(element);
  return array;
}


- (NSArray *)arrayByPerformingBlock:(id   (^)(id element))performBlock
        ifElementPassesTest:(BOOL (^)(id element))testBlock
           elsePerformBlock:(void (^)(id element))elseBlock
               succeded:(void (^)())succesBlock
               failed:(void (^)(id element))failedBlock
           stopOnFailedTest:(BOOL)stop

{
  NSMutableArray *array = [NSMutableArray array];
  for (id element in self){
    if(testBlock(element))
      [array addObject:performBlock(element)];
    else{
      elseBlock(element);
      if (stop) {
        failedBlock(element);
        break;
      }
    }
  }

  if (!stop) {
    succesBlock();
  }
    return array;
}

-(NSSet *)setByPerformingBlock:(id   (^)(id))performBlock
           ifElementPassesTest:(BOOL (^)(id))testBlock
{
    NSMutableSet *set = [NSMutableSet setWithArray:self];
    NSMutableSet *newSet = [NSMutableSet set];
    for (id element in set){
        if (testBlock(element)) {
            [newSet addObject:performBlock(element)];
        }
    }
    if ([newSet count]&lt;1)
        return nil;
    return [NSSet setWithSet:newSet];
}

-(void)performBlock:(void (^)(id))block
{
  for(id element in self) {
    block(element);
  }
}


- (NSDictionary *)dictionaryByFilteringWithBlocks:(NSArray *)filterBlocks forKeys:(NSArray *)keys
{
  NSMutableDictionary *result = [NSMutableDictionary dictionaryWithCapacity:[keys count]];
  for (id key  in keys) {
    [result setObject:[NSMutableArray array] forKey:key];
  }
  for (id element in self) {
    for (NSUInteger i=0; i &lt; [filterBlocks count]; i++) {
      BOOL (^block)(id element)  = [filterBlocks objectAtIndex:i];
      if (block(element))
        [(NSMutableArray *)[result objectForKey:[keys objectAtIndex:i]] addObject:element];
    }
  }
  return result;
}


-(NSArray *)arrayOfArraysWithColumnWidth:(NSUInteger)width
{
    NSAssert(width &gt; 0, @"width need to be 1 or greater");

    NSMutableArray *mArray =[NSMutableArray array];
    [self enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        if (idx % width == 0) {
            [mArray addObject:[NSMutableArray array]];
        }
        [[mArray objectAtIndex:[mArray count]-1] addObject:obj];
    }];
    return mArray;
}


@end
</code></pre>

<h3>NSArray+RandomUtils</h3>

<pre><code class="Objective-C">
@interface NSArray (RandomUtils)
-(id)randomElement;

@end

@interface NSMutableArray (RandomUtils)
-(void)shuffle;
@end
</code></pre>

<pre><code class="Objective-C">#import "NSArray+RandomUtils.h"

@implementation NSArray (RandomUtils)

-(id)randomElement
{
  if ([self count] &lt; 1) return nil;
  int randomIndex = arc4random_uniform((int)[self count]);
  return [self objectAtIndex:randomIndex];
}

@end
</code></pre>

<h3>Example Usage</h3>

<pre><code class="Objective-C">
//
//  main.m
//  arraycomparator
//
//  Created by Manuel Meyer on 05.02.15.
//  Copyright (c) 2015  All rights reserved.
//

#import &lt;Foundation/Foundation.h&gt;
#import "NSArray+FunctionalTools.h"
#import "NSArray+RandomUtils.h"

@interface NSArray (Comparator)
-(NSArray *)vs_sortedArrayUsingComparator:(NSComparisonResult(^)(id obj1, id obj2))comparator;
@end

@implementation NSArray (Comparator)
-(NSArray *) quicksortUsingComparator:(NSComparisonResult(^)(id obj1, id obj2))comparator
{
    NSArray *array = [self copy];

    if ([array count]&lt;2) return [array copy];

    id pivot = [array randomElement];
    NSMutableArray *array2= [NSMutableArray array];

    array = [array arrayByPerformingBlock:^id(id element) { return element;}
                    ifElementPassesTest:^BOOL(id element) { return comparator(element, pivot) == NSOrderedAscending;}
                       elsePerformBlock:^    (id element) { if (element!=pivot) [array2 addObject:element];}
            ];
    return [[[array quicksortUsingComparator:comparator]
                                    arrayByAddingObject:pivot]
                                        arrayByAddingObjectsFromArray:[array2 quicksortUsingComparator:comparator]];
}

-(NSArray *)vs_sortedArrayUsingComparator:(NSComparisonResult(^)(id obj1, id obj2))comparator
{
    return [self quicksortUsingComparator:comparator];
}
@end


int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSArray *array = @[@4, @9, @2, @1, @7];

        array = [array vs_sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) {
            return  [obj1 compare:obj2];
        }];
    }
    return 0;
}
</code></pre>


</div>



<div class="post">

<h2><a href="/2015/01/28/once-and-for-all/">Once and For All — Data Source Adapter Pattern</a></h2>
<h4>28 January 2015</h4>
<p>In iOS and Mac development a plague is spreading around the world.<br/>
Many view controller become so heavy and obese that we must expect our devices
to suffer from Type-II Diabetes. This disease is super-contangeous and it's
ground zero is well known: <a href="http://developer.apple.com">developer.apple.com</a></p>

<h3>What are the symptoms of this syndrome?</h3>

<p>Among others others they are the usual suspects when it come to obisity:</p>

<ul>
<li>hard to move</li>
<li>unflexibel</li>
<li>hard to breed</li>
<li>no sex appeal</li>
</ul>


<h3>Where and how did the current outbreak start?</h3>

<p>It is not known by now where the gems that transport this disease came to
existence, but once they reached <a href="http://developer.apple.com">developer.apple.com</a>, it broke loose.<br/>
Since than it is spreading through the main transport infrastructure like Apple's
sample codes, mailinglists, stackoverflow.com, Books,…</p>



<p><a href="/2015/01/28/once-and-for-all/">read more</a></p>

</div>



</div>

<div id="footer">
  
</div>

      </div>
      <div>
      </div>
    </div>
</div>
</div>
</body>
</html>

